<a name="inicio"></a>

# üìò **THE CURE PROJECT** üßë‚ÄçüíªüöÄ

# Servicio de Audio y V√≠deo para InnovateTech

---

## Introducci√≥n

El servicio de audio y v√≠deo bajo demanda (AOD/VOD) de InnovateTech es un componente cr√≠tico de su plataforma web. Este apartado detalla la implementaci√≥n de un sistema de streaming basado en RTMP para audio y NGINX con el m√≥dulo RTMP/HLS para v√≠deo, utilizando FFmpeg como herramienta de codificaci√≥n y transmisi√≥n. La soluci√≥n est√° optimizada para garantizar eficiencia, escalabilidad y sostenibilidad.

El sistema se prob√≥ inicialmente en un entorno local en una m√°quina Ubuntu, utilizando flujos de audio y v√≠deo enviados a trav√©s de FFmpeg a un servidor Icecast y, posteriormente, integrados con NGINX para streaming HLS. Se desarrollaron scripts de automatizaci√≥n y servicios systemd para garantizar un funcionamiento eficiente y sostenible, con mecanismos de apagado autom√°tico para minimizar el consumo energ√©tico cuando no hay usuarios conectados.


## Implementaci√≥n del Servicio de Audio

### Configuraci√≥n de Icecast para Streaming de Audio

Se configur√≥ un servidor Icecast en una m√°quina Ubuntu (ip-172-31-85-195) para gestionar el streaming de audio en formato MP3. La configuraci√≥n inicial permite pruebas locales, con el flujo enviado desde FFmpeg a un punto de montaje en 

**icecast://source:sjo@localhost:8000/stream** 

El servidor temprano soporta hasta 20 oyentes simult√°neos, con medidas de seguridad como autenticaci√≥n de fuente y oyentes.
El archivo de configuraci√≥n de Icecast se optimiz√≥ para garantizar un equilibrio entre rendimiento y consumo de recursos, habilitando el soporte CORS para permitir la integraci√≥n con reproductores web.

**Comando FFmpeg para Audio**:

```bash
ffmpeg -re -i "01. Main Theme.mp3" -vn -c:a libmp3lame -b:a 128k -f mp3 
icecast://source:sjo@localhost:8000/stream
```

**Configuraci√≥n de Icecast**:

```xml
<icecast>
    <!-- General server info -->
    <location>Earth</location>
    <admin>admin@innovatetech.com</admin>

    <!-- Connection and streaming limits -->
    <limits>
        <clients>20</clients>
        <sources>1</sources>
        <queue-size>524288</queue-size>
        <client-timeout>30</client-timeout>
        <header-timeout>15</header-timeout>
        <source-timeout>10</source-timeout>
        <burst-on-connect>1</burst-on-connect>
        <burst-size>65535</burst-size>
    </limits>

    <!-- Authentication -->
    <authentication>
        <source-password>sjo</source-password>
        <relay-password>sjo</relay-password>
        <admin-user>admin</admin-user>
        <admin-password>sjo</admin-password>
    </authentication>

    <!-- Public server hostname -->
    <hostname>innovatetech.com</hostname>

    <!-- Socket configuration -->
    <listen-socket>
        <port>8000</port>
    </listen-socket>

    <!-- CORS support -->
    <http-headers>
        <header name="Access-Control-Allow-Origin" value="*" />
    </http-headers>

    <!-- Mountpoint configuration -->
    <mount type="normal">
        <mount-name>/innovate.mp3</mount-name>
        <public>1</public>
        <max-listeners>20</max-listeners>
        <authentication type="htpasswd">
            <option name="filename" value="/etc/icecast2/passwd" />
            <option name="allow_duplicate_users" value="0" />
        </authentication>
    </mount>

    <!-- File serving -->
    <fileserve>1</fileserve>

    <paths>
        <basedir>/usr/share/icecast2</basedir>
        <logdir>/var/log/icecast2</logdir>
        <webroot>/usr/share/icecast2/web</webroot>
        <adminroot>/usr/share/icecast2/admin</adminroot>
        <alias source="/" destination="/status.xsl"/>
    </paths>

    <!-- Logging -->
    <logging>
        <accesslog>access.log</accesslog>
        <errorlog>error.log</errorlog>
        <loglevel>2</loglevel>
        <logsize>10000</logsize>
    </logging>

    <!-- Security -->
    <security>
        <chroot>0</chroot>
    </security>
</icecast>
```

**Pruebas de Streaming de Audio**:

Se realizaron pruebas enviando un archivo MP3 (15. Toad House.mp3) a un punto de montaje alternativo (/live.mp3) usando el c√≥dec AAC para mayor eficiencia:

```bash
ffmpeg -re -i "15. Toad House.mp3" -vn -c:a aac -b:a 128k -f flv
rtmp://34.204.241.226:1935/live/stream

```

El flujo era accesible en http://13.219.197.73:8000/live.mp3.

### Scripts de Automatizaci√≥n

Se desarrollaron scripts para gestionar el streaming de audio como un servicio, con se√±ales de "ping" para detener la transmisi√≥n cuando no hay oyentes, reduciendo el consumo energ√©tico. Estos scripts se integraron en un servicio systemd (player-loop.service) para garantizar un funcionamiento continuo y automatizado, el mismo se conect√≥ m√°s tarde con el servidor Nginx para darle un frontend web, aunque no se ped√≠a, esto lo hicimos para realizar una implementaci√≥n m√°s realista y darle un uso a la p√°gina web.

## Implementaci√≥n del Servicio de V√≠deo

### Configuraci√≥n de NGINX con M√≥dulo RTMP/HLS

Para el streaming de v√≠deo/audio, se compil√≥ una versi√≥n personalizada de NGINX (versi√≥n 1.24.0) con soporte para el m√≥dulo RTMP y HLS, permitiendo la distribuci√≥n del contenido en formato adaptativo. El servidor se configur√≥ para servir contenido desde /var/www/html, con archivos como index.html para la interfaz web y hls para los segmentos de audio/video. Adem√°s se configur√≥ el socket de PHP por problemas de incompatibilidad.

**Comando FFmpeg para V√≠deo**:

```bash
ffmpeg -re -stream_loop -1 -i /home/ubuntu/video/walle.mp4 -c:v libx264 -preset veryfast -maxrate 1000k -bufsize 2000k -g 50 -c:a aac -b:a 128k -ar 44100 -ac 2 -f flv rtmp://innovatetech.duckdns.org/live/stream

```

Configuraci√≥n HLS:
Se implement√≥ HLS para streaming adaptativo, generando segmentos de 4 segundos con una lista de reproducci√≥n de 5 segmentos, eliminando segmentos antiguos para optimizar el almacenamiento:

```bash
ffmpeg -re -i video.mp4 -c:v libx264 -preset veryfast -tune zerolatency -c:a aac -f hls -hls_time 4 -hls_list_size 5 -hls_flags delete_segments ~/hls_output/index.m3u8
```

**Scripts de Automatizaci√≥n para Streaming de Audio y V√≠deo**:

Para garantizar un funcionamiento eficiente y sostenible, se desarrollaron dos scripts en Bash (player-loop.sh para audio y player-video-loop.sh para v√≠deo) que automatizan el proceso de streaming.

### Automatizaci√≥n de Streaming de Audio (player-loop.sh)

El script player-loop.sh gestiona el streaming de audio mediante las siguientes funciones:

- Selecciona aleatoriamente archivos de audio desde el directorio /home/ubuntu/music y los transmite al URL RTMP rtmp://34.204.241.226:1935/live/stream usando FFmpeg con el c√≥dec AAC a 128 kbps.
- Verifica la presencia de espectadores cada 2 segundos mediante SSH a un servidor secundario (ec2-34-204-241-226.compute-1.amazonaws.com), leyendo el archivo /tmp/last_ping para determinar si hay usuarios conectados.
- Extrae metadatos (t√≠tulo y artista) de los archivos de audio usando ffprobe y los env√≠a como JSON al servidor secundario (/tmp/current_song.json) para mostrarlos en la interfaz web.
- Implementa un tiempo de inactividad de 5 minutos (300 segundos), deteniendo el stream y finalizando el proceso si no hay espectadores, reduciendo as√≠ el consumo energ√©tico.
- Permite saltar manualmente a la siguiente canci√≥n verificando la existencia del archivo /tmp/next_song, que termina el proceso FFmpeg actual.

**Script: player-loop.sh**

```bash
#!/bin/bash

MUSIC_DIR="/home/ubuntu/music"
RTMP_URL="rtmp://34.204.241.226:1935/live/stream"

# Comunicaci√≥n con servidor B
KEY_PATH="/home/ubuntu/scripts/innovatech-key.pem"
USER_B="ubuntu"
HOST_B="ec2-34-204-241-226.compute-1.amazonaws.com"
DEST_PATH="/tmp/current_song.json"

# Tiempo m√°ximo sin viewers antes de apagar (en segundos)
INACTIVITY_TIMEOUT=300  # 5 minutos

check_web_viewers() {
  local LAST_PING=$(ssh -i "$KEY_PATH" -o StrictHostKeyChecking=no "$USER_B@$HOST_B" 'cat /tmp/last_ping 2>/dev/null || echo 0')
  local NOW=$(date +%s)
  local DIFF=$((NOW - LAST_PING))
  if [ "$DIFF" -lt 30 ]; then
    echo 1
  else
    echo 0
  fi
}

while true; do
  echo "‚è≥ Esperando espectadores web..."
  last_viewer_time=$(date +%s)

  while true; do
    VIEWERS=$(check_web_viewers)
    echo "üëÄ Viewers conectados: $VIEWERS"

    if [ "$VIEWERS" -gt 0 ]; then
      break  # Empezar a reproducir
    fi

    current_time=$(date +%s)
    diff=$((current_time - last_viewer_time))
    if [ "$diff" -ge "$INACTIVITY_TIMEOUT" ]; then
      echo "üõë Sin viewers por $INACTIVITY_TIMEOUT segundos. Apagando para ahorrar energ√≠a."
      exit 0
    fi

    sleep 3
  done

  echo "üéµ Comenzando reproducci√≥n porque hay espectadores."

  mapfile -t SONGS < <(find "$MUSIC_DIR" -type f | shuf)

  for SONG in "${SONGS[@]}"; do
    VIEWERS=$(check_web_viewers)
    if [ "$VIEWERS" -eq 0 ]; then
      echo "üö´ Nadie conectado. Parando reproducci√≥n y regresando al modo espera."
      break
    fi

    echo "‚ñ∂Ô∏è Reproduciendo: $SONG"

    METADATA=$(ffprobe -v quiet -show_entries format_tags=title,artist -of json "$SONG")
    TITLE=$(echo "$METADATA" | jq -r '.format.tags.title // "Desconocido"')
    ARTIST=$(echo "$METADATA" | jq -r '.format.tags.artist // "Desconocido"')

    echo "{\"title\": \"$TITLE\", \"artist\": \"$ARTIST\"}" > /tmp/current_song.json
    scp -i "$KEY_PATH" -o StrictHostKeyChecking=no /tmp/current_song.json "$USER_B@$HOST_B:$DEST_PATH"

    ffmpeg -re -i "$SONG" -vn -c:a aac -b:a 128k -f flv "$RTMP_URL" &
    FFMPEG_PID=$!

    while kill -0 $FFMPEG_PID 2>/dev/null; do
      if [ -f /tmp/next_song ]; then
        echo "‚è≠Ô∏è Siguiente solicitado, matando FFmpeg..."
        kill -9 $FFMPEG_PID
        rm -f /tmp/next_song
        break
      fi

      VIEWERS=$(check_web_viewers)
      if [ "$VIEWERS" -eq 0 ]; then
        echo "üõë Nadie conectado. Deteniendo reproducci√≥n."
        kill -9 $FFMPEG_PID
        break
      fi

      sleep 2
    done

    sleep 2
  done

  last_viewer_time=$(date +%s)
done
```

### Automatizaci√≥n de Streaming de V√≠deo (player-video-loop.sh)

El script player-video-loop.sh gestiona el streaming de v√≠deo mediante las siguientes funciones:

- Selecciona aleatoriamente archivos de v√≠deo (formatos MP4, MKV, AVI) desde el directorio /home/ubuntu/video y los transmite al URL RTMP rtmp://innovatetech.duckdns.org/live/stream usando FFmpeg con el c√≥dec H.264 (maxrate 1000k, bufsize 2000k) y audio AAC a 128 kbps.
- Verifica la presencia de espectadores cada 2 segundos mediante SSH al servidor secundario (innovatetech.duckdns.org), leyendo el archivo /tmp/last_ping_video para determinar si hay usuarios conectados.
- Implementa un tiempo de inactividad de 5 minutos (300 segundos), deteniendo el stream y finalizando el proceso si no hay espectadores, optimizando el consumo energ√©tico.
- Monitorea continuamente el proceso FFmpeg, deteni√©ndolo si no hay espectadores, asegurando un uso eficiente de los recursos del servidor.

**Script: player-video-loop.sh**

```bash
#!/bin/bash

VIDEO_DIR="/home/ubuntu/video"
RTMP_URL="rtmp://innovatetech.duckdns.org/live/stream"

KEY_PATH="/home/ubuntu/scripts/innovatech-key.pem"
USER_B="ubuntu"
HOST_B="innovatetech.duckdns.org"
INACTIVITY_TIMEOUT=300  # 5 minutos

check_web_viewers() {
  local LAST_PING=$(ssh -i "$KEY_PATH" -o StrictHostKeyChecking=no "$USER_B@$HOST_B" 'cat /tmp/last_ping_video 2>/dev/null || echo 0')
  LAST_PING=$(echo $LAST_PING | tr -dc '0-9')
  local NOW=$(date +%s)
  local DIFF=$((NOW - LAST_PING))
  if [ "$DIFF" -lt 30 ]; then
    echo 1
  else
    echo 0
  fi
}

while true; do
  echo "‚è≥ Esperando espectadores web..."
  last_viewer_time=$(date +%s)

  while true; do
    VIEWERS=$(check_web_viewers)
    echo "üëÄ Viewers conectados: $VIEWERS"

    if [ "$VIEWERS" -gt 0 ]; then
      break  # Empezar a reproducir
    fi

    current_time=$(date +%s)
    diff=$((current_time - last_viewer_time))
    if [ "$diff" -ge "$INACTIVITY_TIMEOUT" ]; then
      echo "üõë Sin viewers por $INACTIVITY_TIMEOUT segundos. Apagando para ahorrar energ√≠a."
      exit 0
    fi

    sleep 3
  done

  echo "‚ñ∂Ô∏è Comenzando transmisi√≥n porque hay espectadores."

  mapfile -t VIDEOS < <(find "$VIDEO_DIR" -type f \( -iname "*.mp4" -o -iname "*.mkv" -o -iname "*.avi" \) | shuf)

  for VIDEO in "${VIDEOS[@]}"; do
    VIEWERS=$(check_web_viewers)
    if [ "$VIEWERS" -eq 0 ]; then
      echo "üö´ Nadie conectado. Parando transmisi√≥n y regresando al modo espera."
      break
    fi

    echo "‚ñ∂Ô∏è Reproduciendo: $VIDEO"

    ffmpeg -re -i "$VIDEO" \
      -c:v libx264 -preset veryfast -maxrate 1000k -bufsize 2000k -g 50 \
      -c:a aac -b:a 128k -ar 44100 -ac 2 \
      -f flv "$RTMP_URL" &
    FFMPEG_PID=$!

    while kill -0 $FFMPEG_PID 2>/dev/null; do
      VIEWERS=$(check_web_viewers)
      if [ "$VIEWERS" -eq 0 ]; then
        echo "üõë Nadie conectado. Deteniendo transmisi√≥n."
        kill -9 $FFMPEG_PID
        break
      fi
      sleep 2
    done

    sleep 2
  done

  last_viewer_time=$(date +%s)
done

```

**Interfaz Web para contenido:**

Se desarroll√≥ una p√°gina web sencilla utilizando HLS.js para reproducir el stream HLS en navegadores modernos:

```html
<!DOCTYPE html>
<html>
<head>
    <title>Stream en Directe</title>
    <script src="https://cdn.jsdelivr.net/npm/hls.js@latest"></script>
</head>
<body>
    <h1>Stream en Directe</h1>
    <video id="video" controls autoplay width="640" height="360"></video>

    <script>
        var video = document.getElementById('video');
        if (Hls.isSupported()) {
            var hls = new Hls();
            hls.loadSource('stream.m3u8');
            hls.attachMedia(video);
            hls.on(Hls.Events.MANIFEST_PARSED, function() {
                video.play();
            });
        } else if (video.canPlayType('application/vnd.apple.mpegurl')) {
            video.src = 'stream.m3u8';
            video.addEventListener('loadedmetadata', function() {
                video.play();
            });
        }
    </script>
</body>
</html>

```

**Acceso al contenido**:

El flujo multimedia est√° disponible en http://innovatetech.duckdns.org/

### Compilaci√≥n y Configuraci√≥n de NGINX

Se descarg√≥ y compil√≥ NGINX 1.24.0 con los m√≥dulos necesarios:

```bash
cd /usr/local/src
wget http://nginx.org/download/nginx-1.24.0.tar.gz
tar zxvf nginx-1.24.0.tar.gz
cd nginx-1.24.0
./configure --prefix=/usr/local/nginx --with-http_ssl_module --with-http_v2_module --with-stream --add-module=/path/to/nginx-rtmp-module
make
sudo make install
```


Se cre√≥ un servicio **systemd** personalizado (nginx-custom.service) para gestionar NGINX:

```ini
[Unit]
Description=NGINX Custom compiled server
After=network.target

[Service]
Type=forking
ExecStart=/usr/local/nginx/sbin/nginx
ExecReload=/usr/local/nginx/sbin/nginx -s reload
ExecStop=/usr/local/nginx/sbin/nginx -s quit
PIDFile=/usr/local/nginx/logs/nginx.pid
Restart=on-failure

[Install]
WantedBy=multi-user.target
```

## Comandos de Gesti√≥n de NGINX:

| Efecto                     | **Comando**                                               |
|----------------------------|-----------------------------------------------------------|
| Iniciar el servicio        | `sudo systemctl start nginx-custom.service`              |
| Detener el servicio        | `sudo systemctl stop nginx-custom.service`               |
| Reiniciar el servicio      | `sudo systemctl restart nginx-custom.service`            |
| Recargar configuraci√≥n     | `sudo systemctl reload nginx-custom.service`             |
| Ver estado del servicio    | `sudo systemctl status nginx-custom.service`             |
| Verificar configuraci√≥n    | `/usr/local/nginx/sbin/nginx -t`                         |
| Habilitar al inicio        | `sudo systemctl enable nginx-custom.service`             |

## Comandos de Gesti√≥n de VOD/AOD

Para ver los loggins en vivo

```bash
sudo journalctl -u player-loop.service -f ‚Üí Ver logging en vivo.
sudo journalctl -u video-stream.service -f ‚Üí Ver logging en vivo.
```
Se deben adaptar los comandos de gesti√≥n de NGINX para usarlos con los otros servicios. Por ejemplo: stop, start, enable, etc.

# Directorio de Contenido Web

El directorio `/var/www/html` contiene los archivos necesarios para la interfaz web y el streaming:

```bash
about.html
css/
current_song.php
fonts/
grid.html
highway-loop.mp4
hls/
img/
index.html
index.html.bak
index.nginx-debian.html.bak
info.php
js/
masonry.html
next.php
next_song_trigger.php
ping.php
ping_video.php
prepros-6.config
script/
srv-audio-innovatetech.pem
templatemo_520_highway_1.zip
video/
```

## Optimizaci√≥n y Sostenibilidad

### Codificaci√≥n Eficiente

- **Audio**: Se utiliza el c√≥dec `AAC (128 kbps)` para streaming de audio, proporcionando alta calidad con bajo consumo de ancho de banda, reduciendo la carga en la red y el consumo energ√©tico.
- **V√≠deo**: El c√≥dec `H.264` con los ajustes `preset=veryfast` y `tune=zerolatency` optimiza la latencia y el uso de recursos, con `maxrate=1000 kbps` y `bufsize=2000 kbps` para garantizar estabilidad.

### Escalado Adaptativo

- Aunque no implementado en esta versi√≥n inicial, la arquitectura `HLS` permite la futura integraci√≥n de *streaming adaptativo*, ajustando la calidad seg√∫n el ancho de banda del usuario y minimizando el consumo innecesario de datos.

### Apagado Autom√°tico

- Scripts de monitoreo (`ping.php`, `ping_video.php`) env√≠an se√±ales para detener los procesos de streaming cuando no hay usuarios conectados, reduciendo el consumo energ√©tico y aline√°ndose con los ODS **7** y **12**.

### Hardware Eficiente

- El uso de servidores con certificaci√≥n `EnergyStar` o equivalente asegura un bajo consumo energ√©tico.
- Se complementa con virtualizaci√≥n o contenedores (como `Docker`) para optimizar recursos.

### Automatizaci√≥n

- Los servicios `systemd` (`nginx-custom.service`, `player-loop.service`) automatizan la gesti√≥n del streaming, evitando operaciones manuales redundantes y mejorando la eficiencia operativa.


---

[**‚¨ÜÔ∏è Volver al inicio**](#inicio)
